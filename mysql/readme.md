
## 索引

### 索引类型
* 二叉树，红叉树
* hash 索引
* B-树
* B+树

### 索引分类
* 主键索引
* 唯一索引
* 联合索引
* 普通索引

### 索引失效的场景
* 数据类型不一致
* 字段有函数操作例（+，-，*，/）
* 使用不等于查询（!=,<>,where null , not null）
* like 查询
* 当 mysql 分析全表扫描比使用索引快的时候不使用索引

### 聚簇索引，和非聚簇索引的区别
* 聚簇索引：(索引和主键在一个文件) 节点存放的是主键和数据，主键下面就是数据，会索引覆盖 (innodb)            
* 非聚簇索引： (索引和数据分开的) 节点存放主键值,然后通过主键值再去回表查找数据 (如果只童找索引本身，那就不回表) (MyisAm)

如果一个索引包含(或者说覆盖) 所有需要查询的字段的值，我们就称 之为“翟盖索引”。



## 事务

### 事务的特性
* 原子性
    * 要么全部成功，要么全部失败
* 一致性
    * 状态总是从一个状态转移到另一个状态，不存在中间状态
* 隔离性
    * 事务提交前，对于其它事务是不可见的
* 持久性
    * 一旦提交不可改变，永远都是这样
### 事务的回滚机制
* 事务处理时，会记录在 undo log 中，通过 undo log 进行回滚

 我们在进行数据更新操作的时候，不仅会记录redo log，还会记录undo log，如果因为某些原因导致事务回滚，那么这个时候MySQL就要执行回滚（rollback）操作，利用undo log将数据恢复到事务开始之前的状态

* undo log的配置参数
```
innodb_max_undo_log_size:   undo日志文件的最大值，默认1GB，初始化大小10M
innodb_undo_log_truncate:   标识是否开启自动收缩undo log表空间的操作
innodb_undo_tablespaces:    设置独立表空间的个数，默认为0，标识不开启独立表空间，undo日志保存在ibdata1中
innodb_undo_directory:      undo日志存储的目录位置
innodb_undo_logs:           回滚的个数 默认128
```

### 事务的隔离级别
* 读未提交（read uncommited），脏堵，不可重复读，幻读
* 读已提交（read commited），不可重复读，幻读
* 可重复读（reqeatable read），默认等级，幻读
* 串行化（serialable），解决所以问题，但是吞吐不高，容易造成数据库阻塞，效率低



## 锁

### 按照粒度划分
    
   * 行锁
     * 行锁分析
        * show status like 'innodb_row_lock%';
   * 页锁
       
   * 表锁
      
### 使用方法
   * 共享锁（乐观锁，lock in share mode）
        * select xxx lock in share mode
   * 排它锁 （悲观锁，for update）
        * select xxx for update
    
### 死锁
 
  * 造成死锁的原因
    * 指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象
  * 造成死锁的必要条件
    * 互斥条件：        一个资源每次只能被一个进程使用
    * 请求和保持条件：   一个进程因请求资源而阻塞时，对已获得的资源保持不放
    * 不剥夺条件：       进程已获得的资源，在没有使用完之前，不能强行剥夺
    * 环路等待条件：     多个进程之间形成的一种互相循环等待的资源的关系
  * 解决死锁的基本方法
    * 查看死锁：show engine innodb status
    * 自动检测机制，超时自动回滚代价较小的事务（innodb_lock_wait_timeout 默认50s）
    * 人为解决，kill阻塞进程（show processlist）
    * wait for graph 等待图（主动检测）
  * 如何避免
    *  加锁顺序一致，尽可能一次性锁定所需的数据行
    *  尽量基于primary（主键）或unique key更新数据
    *  单次操作数据量不宜过多，涉及表尽量少
    *  减少表上索引，减少锁定资源
    *  尽量使用较低的隔离级别
    *  尽量使用相同条件访问数据，这样可以避免间隙锁对并发的插入影响
    *  精心设计索引，尽量使用索引访问数据
    *  借助相关工具：pt-deadlock-logger


---







